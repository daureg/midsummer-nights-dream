We first describe two primitives we use to implement \gtx{}, namely \extractStar{} and
\collapseStar{}.

\extractStar{} takes as input a graph $G_t=(V_t, E_t)$, and optionally a \emph{threshold function}
$t_f$ or a \emph{degree function} $d_f$. While the graph is not exhausted, it repeatedly samples a
star center $c_i$, creates a star $S_i^t$ with $c_i$ neighbors, removes all the nodes of $S_i^t$ from
$V_t$ and all the edges incident to $S_i^t$ from $E_t$, and finally decrements the degree of the 2-hop
neighbors of $c_i$.
\begin{marginfigure}
  \centering
  \includegraphics[height=0.15\textheight]{assets/tikz/gtx_star_tikz.pdf}
  \caption[A sample star]{A sample star created at the $t^\mathrm{th}$ level. The black node
    % \tikz{\node[vertex,rare] {$c_i$};}
    is the center $c_i$ of the star $S_i^t$, which is made of the four light gray peripheral nodes
  % \tikz{\node[vertex,medium] {$p_1$};} to \tikz{\node[vertex,medium] {$p_4$};}
  as well as the solid edges. The 2-hops neighbors of $c_i$ are the white nodes
  % \tikz{\node[vertex] {$h_1$};} to \tikz{\node[vertex] {$h_3$};}
  $h_1$ to $h_3$, whose degree will decrease once we $S_i^t$ is removed from $G_t$.}
  \label{fig:gtx_star_simple}
\end{marginfigure}
Upon completion, it returns a list of stars and a mapping of
each node of $V_t$ to the unique star it belongs to. We consider three heuristics to choose centers:

\begin{itemize}
  \item choose the node with the current highest degree, with ties broken arbitrarily
  \item if $n_i$ is the number of node remaining in $V_t$ before choosing the \ith{} center, choose
    a node \uar{} among those with a degree larger than $t_f(n_i)$. Setting the threshold function
    to be the identity therefore recovers the previous strategy, but the idea here is to choose
    among a small set of high degree nodes, for instance by letting $t_f(n) = \sqrt{n}$
  \item if $\degr(u)$ is the degree of node $u$, choose node proportionally to $d_f(\degr(u))$, where
    again the degree function favors high degree nodes, for instance $d_f(\degr(u)) = \degr(u)^2$.
\end{itemize}

Let us analyze the complexity of the highest degree heuristic when $|V_t|=n$ and $|E_t|=m$. We first
build a priority queue of all the nodes sorted by their degree, which takes $O(n)$ time.  Then, at
each iteration of the inner loop, we find the center of the next star by extracting the maximum of
the queue, and we decrease the priority (\ie the degree) of all nodes adjacent to the new star.
Since both operations require constant time when using a Strict Fibonacci
Heap~\autocite{FibonacciHeaps12} and there are at most $n$ iterations of that loop, a coarse
approximation of the runtime of \extractStar{} is $O(n^2)$. However, observe that there can be at
most $m$ decrease operations (since degree $0$ nodes form a singleton star in constant time),
reducing the complexity to $O(m)$.

\bigskip

The second routine, \collapseStar{} takes as input the result of \extractStar{}, along with $E_t$
and an optional $\emph{eccentricity}$ array we will describe soon. It builds a new graph $G_{t+1}$
where each star becomes a node and there is a link between two nodes $s_1$ and $s_2$ if the nodes
making up $s_1$ and $s_2$ are connected in $E_t$. For that, we first shuffle $E_t$ and go through
it. When we  find an edge w hose endpoints belong to two different stars not yet connected, we use
that edge to connect these two stars. This trivially takes $O(m)$ times.

A variant instead keeps track of all edges connecting each pair of stars to choose one that will
best contribute to our low stretch objective. Namely, when connecting two stars, we would prefer to
join their centers rather than two peripheral points. For that we maintain an eccentricity count for
all of the nodes of the original $G_0$, which is incremented by $1$ each time a node is chosen to be
on the periphery of a star.\Todo{Show an example of a small 3 levels nested stars}
For each pair of stars, we thus choose the edge across them with minimal sum of its endpoints'
eccentricity. This requires another pass over the edges, preserving the $O(m)$ runtime.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.98\linewidth]{tikz/gtx_eccentricity_tikz.pdf}
  \caption[The hierarchical structure of stars created by \gtx{}]{%
    The execution of the \gtx{} algorithm. The original graph is made of the solid edges
    connecting the nodes labeled by their id. Edges forming the final spanning tree are in black
    while the others are in gray. The four shades of gray, from white to dark gray
    denote increasing node eccentricity (as computed at the end of the algorithm). The \ith{} star
    created during the \jth{} iteration of the algorithm is denoted $S_i^j$. Refer to the main text
    for a complete walk through.}
  \label{fig:gtx_eccentricity}
\end{figure}

\begin{figure}[bthp]
  \centering
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[height=7cm]{tikz/gtx_run_level1_tikz}
    \caption{Resulting graph after the first iteration}\label{fig:gtx_run1}
  \end{subfigure}~
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[height=3cm]{tikz/gtx_run_level2_tikz}
    \caption{Resulting graph after the second iteration}\label{fig:gtx_run2}
    \vspace{\baselineskip}
    \includegraphics[height=3cm]{tikz/gtx_run_level3_tikz}
    \caption{Resulting graph after the third iteration}\label{fig:gtx_run3}
  \end{subfigure}~
  \caption{The other iterations of \gtx{}}\label{fig:gtx_run}
\end{figure}

\bigskip

Let us start with the initial graph $G_0$ depicted in \autoref{fig:gtx_eccentricity} and initialize
the eccentricity of all nodes to $0$. When running \extractStar{}, we see that the maximum degree is
$4$, achieved at nodes $\{1, 6, 11, 16, 21, 26, 31, 36, 41\}$. For the sake of simplicity, assume
nodes are picked according to their id. First, node $1$ is gonna form the star
$\textcolor{DodgerBlue}{S_1^1}$ with peripheral nodes $2$, $3$, $4$ and $5$. This will increment the
eccentricity of those peripheral nodes by $1$. Then node $6$ forms its star
$\textcolor{DodgerBlue}{S_2^1}$ with $7$,$8$,$9$ and $10$. The process continues until node $41$ is
chosen to be the center of star $\textcolor{DodgerBlue}{S_9^1}$, at which point $V_0$ has been
exhausted and \extractStar{} terminates.

We then call \collapseStar{}, with the eccentricity reducing variant. This will create all possible
links between pairs of star. For instance, the edge between nodes $19$ and $29$ leads to the edge
between $\textcolor{DodgerBlue}{S_4^1}$ and $\textcolor{DodgerBlue}{S_6^1}$. This was actually the
only possible edge between $\textcolor{DodgerBlue}{S_4^1}$ and $\textcolor{DodgerBlue}{S_6^1}$.
Consider on the other hand the case of edges $(2, 6)$ and $(2, 9)$. They both connect
$\textcolor{DodgerBlue}{S_1^1}$ and $\textcolor{DodgerBlue}{S_2^1}$. Yet at this point in time, the
eccentricity of node $2$ is $1$, the eccentricity of node $6$ is $0$ and the eccentricity of node
$9$ is $1$. The edge $(2, 6)$ has therefore the smallest total eccentricity and is chosen to connect
$\textcolor{DodgerBlue}{S_1^1}$ and $\textcolor{DodgerBlue}{S_2^1}$. The full result of the
\collapseStar{} procedure can be seen on \autoref{fig:gtx_run1}.

We are then ready to describe the complete \gtx{} algorithm.\footnote{Note that for clarity, we
removed some bookkeeping, mainly related to maintaining mapping between nodes at different level of
contraction. Yet the full python implementation is available at
\url{https://github.com/daureg/magnet/blob/master/veverica/new_galaxy.py}.} Intuitively, until each
connected component is reduced to a single node, we first extract stars from the current graph $G_t$
and then collapse them to form $G_{t+1}$.
